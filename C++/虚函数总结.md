必看
https://zhuanlan.zhihu.com/p/54145222
https://www.cnblogs.com/zkfopen/p/11061414.html

# 虚函数
虚函数实现c++的多态性，通过基类的指针指向子类的对象，或者基类的引用绑定子类的对象，来调用子类重写的函数。

# 实现机制 虚函数表vtbl和虚表指针vptr
编译器给有虚函数的类增加虚函数表，是个函数查询表，保存每个虚函数的函数指针，指针指向的是该类派生最远的函数实现
如果子类重写了父类的虚函数，子类的虚函数表里就会指向子类的函数实现

每个类使用一个虚函数表，每个类对象用一个虚表指针。
每个类的实例有一个虚表指针，指向这个类的虚函数表，当调用虚函数时，通过虚表指针查找虚表，然后调用虚函数。



# 纯虚函数 和 抽象类
1. 纯虚函数
没有具体实现的虚函数，只是声明子类要重写这些纯虚函数
纯虚函数的定义很简单：函数声明后紧跟着=0

2. 抽象类
抽象类包含至少一个纯虚函数的类。
抽象类不能实例化对象!
当继承一个抽象类时，必须重写所有纯虚函数，否则继承出来的类也是一个抽象类。
抽象类至少包含一个纯虚函数，抽象类提供了一种禁止其他代码直接实例化对象的方法，但是重写纯虚方法的派生类可以实例化。
如果子类是一个非抽象类的的话，必须重写父抽象类的所有抽象方法，如果子类是一个抽象类的话，可以重写父抽象类的抽象方法，也可以继承父抽象类的抽象方法~
```
class Animal
{
public:
    Animal(const string& name):
        m_name{name}
    {}

    const string& getName() const
    {
        return m_name;
    }

    virtual string speak() const = 0;  // 纯虚函数
    // 因为包含一个纯虚方法，所以是抽象基类

private:
    string m_name;
};

class Cat : public Animal
{
public:
    Cat(const string& name): 
        Animal(name)
    {}

    // 重写了纯虚方法，所以Cat不是抽象类，可以实例化
    virtual string speak() const
    {
        return "Meow";
    }
};

// Dog没有重写基类的纯虚方法，所以仍然无法实例化
class Dog : public Animal
{
public:
    Dog(const string& name):
        Animal(name)
    {}
};

int main()
{
    // Animal animal{"luly"}; // 无法编译，因为抽象基类无法实例化
    Cat cat{ "Sally" };      // 合法
    // Dog dog{ "Betsy" };      // 非法，抽象类无法实例化

    // 下面的代码可以运行，因为可以指向可以实例化的派生类对象
    Animal* aPtr = new Cat{ "Sally" }; 
    cin.ignore(10);
        return 0;
}
```

# override标识符
防止重写失败。告诉编译器这个是重写的函数，如果函数签名不匹配，那么将无法通过编译。
```
class Super
{
public:
    virtual string getName1(int x)
    {
        return "Super";
    }

    virtual string getName2(int x)
    {
        return "Super";
    }
};

class Sub: public Super
{
public:
    virtual string getName1(double x) override
    {
        return "Sub";
    }

    virtual string getName2(int x) const override
    {
        return "Sub";
    }
    // 此时无法编译
};
```

# final标识符
1. 避免子类重写基类的虚函数。使用final标识符，如果子类重写了基类虚函数，那么将无法编译
```
class A
{
public:
    virtual void someMethod() { cout << "A" << endl; }
}

class B: public A
{
public:
    // 基类A的someMethod方法没有final标识符，那么B可以重写该方法
    // 但是此虚方法使用了final标识符，后面的派生类无法重写
    virtual void someMethod() override final { cout << "B" << endl; }
}

class C: public B
{
public:
    // 无法编译，因为不允许重写
    virtual void someMethod() override { cout << "C" << endl; }
}
```
2. final标识符还可以直接用于类，此时该类将不能被继承：
```
class A
{
public:
    virtual void someMethod() { cout << "A" << endl; }
};

// B可以继承A
class B final: public A
{
public:
    virtual void someMethod() override { cout << "B" << endl; }
};

// B无法被继承，此时无法编译
class C: public B
{
public:
    virtual void someMethod() override { cout << "C" << endl; }
};
```


# 析构函数要声明为虚函数
避免内存泄漏。如果没有声明为虚函数，删除基类指向子类对象的指针，不会调用子类的析构函数和子类数据成员的析构函数，造成内存泄漏。
```
class Resource
{
public:
    Resource() { cout << "Resource created!" << endl; }
    ~Resource() { cout << "Resource destoryed!" << endl; }
};

class Super
{
public:
    Super() { cout << "Super constructor called!" << endl; }
    ~Super() { cout << "Super destructor called!" << endl; }
};

class Sub : public Super
{
public:
    Sub() { cout << "Sub constructor called!" << endl;}

    ~Sub() { cout << "Sub destructor called!" << endl；}
private:
    Resource res;
};
```
如果执行下面的代码：

```
int main()
{
    Sub* sub = new Sub;
    Super* super = sub;
    delete super;

    cin.ignore(10);
        return 0;
}
```
其输出为：
```
Super constructor called!
Resource created!
Sub constructor called!
Super destructor called!
```
可以看到，派生类的析构函数没有执行，其数据成员Resource也没有被析构。但是如果你将析构函数都声明为虚函数，上面的代码将得到如下的结果：
```
Super constructor called!
Resource created!
Sub constructor called!
Resource destoryed!
Sub destructor called!
Super destructor called!
```



友元不可以为虚函数
友元不是成员函数，是类外函数，
