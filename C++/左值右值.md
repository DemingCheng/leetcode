[1] https://mp.weixin.qq.com/s/_9-0iNUw6KHTF3a-vSMCmg

# 左值 右值
左值是可以放等号左边的，可以取地址的，有名的值。
包括变量名，函数名，
返回左值引用的函数调用，
前置自增自减
用赋值表达式或者赋值运算符连接的表达式（a=b, a+=b）
解引用表达式 *p

右值
分为纯右值和将亡值
纯右值包括字面量，
返回值是非引用类型的函数调用
算术表达式（a+b a*b a&&b a==b）
取地址表达式（&a）


将亡值
c++11新增的和右值引用相关的表达式
将要被移动的对象
T&& 函数的返回值
std::move函数的返回值
转换为T&&类型转换函数的返回值，
将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。

# 右值引用
目的：
1. 延长生命周期

2. 转移不可拷贝的资源
在C++11中引入了右值引用，目的是延长右值的生命周期，重用右值。
右值引用是&&即由2个&表示，而左值引用是一个&表示。右值引用的作用是为了绑定右值。
[1]


# 移动语义 std::move
转移资源的所有权，避免拷贝的开销。
实现上是通过移动构造函数
class A {
    A() {

    }
    A(int size) {
        size_ = size;
        data_ = new int[size];
    }
    ~A() {
        if(data_ != nullptr) {
            delete[] data_;
        }
    }
    A(const A& a) {
        size_ = a.size;
        data_ = new int[size_];
        cout << "A(const A& a)" << endl;
    }
    A(A&& a) {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "A(A&& a)" << endl;
    }
private:
    int size_;
    int* data_;
};

int main() {
    A a(10);
    A b = a;
    A c = std::move(a);
    return 0;
}


# 移动语义 std::move