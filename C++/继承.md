https://blog.csdn.net/naibozhuan3744/article/details/114192980
https://zhuanlan.zhihu.com/p/596288935

虚基类 和 多重继承中的菱形继承
class x1:virtual public x    //virtual也可以写在public后面
{
//……
};
虚基类可以解决二义性的问题
其实说白了就是解决多重多级继承造成的二义性问题。例如有基类B，从B派生出C和D，然后类F又同时继承了C和D，现在类F的一个对象里面包含了两个基类B的对象，如果F访问自己的从基类B那里继承过来的的数据成员或者函数成员那么编译器就不知道你指的到底是从C那里继承过来的B对象呢还是从D那里继承过来的B对象。

于是虚基类诞生了，将C和D的继承方式改为虚继承，那么F访问自己从B那里继承过来的成员就不会有二义性问题了，也就是将F对象里的B对象统一为一个，只有一个基类B对象




菱形继承
一个祖父类派生出父类和母类，祖孙类同时继承了父类和母类。这就是菱形继承。
两个问题：
一个是数据冗余，祖孙类间接继承了两次祖父类，导致祖孙类的对象模型里包含两个祖父类的数据成员，一个来源于父类，一个来源于母类，浪费空间。

ps. 
只有非静态成员才占对象模型的内存；
类对象的静态变量和静态函数都不占用对象模型的内存，存放在静态储存区；
类对象的普通成员函数也不占用对象模型的内存，存放在普通数据区

二是二义性，祖孙类不能直接访问祖父类的数据成员，要加上（明确调用路径）
D.val = 1 ;             //二义性错误,调用的是B的val还是C的val？
D.B::val = 1;           //正确
D.C::val = 1;           //正确  //明确调用路径



# 切片
赋值转换——切片
子类对象可以赋值给 父类的对象 / 父类的指针 / 父类的引用。这里有个形象的说法叫切片或者切割。寓意把子类中父类那部分切来赋值过去。并且这个过程中没有类型转换。没有类型转换也意味着不产生临时变量！，临时变量具有常性，所以不需要加上const

赋值转换也称为向上转换，子类可以给父类的对象，指针、引用。而向下装换是不行的：父类对象不能赋值给子类对象，子类有的成员而父类没有，缺少的部分怎么去给


不要把虚函数表和虚基表搞混了：在多态中，虚函数表是存放虚函数的地址。在继承中，虚基表存储偏移量，解决菱形继承中的代码冗余与二义性