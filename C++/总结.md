C和C++的区别
编译过程
指针和引用的区别（4点）
struct和class的区别
# static关键字
静态全局变量
静态局部变量
静态函数
类的静态成员变量
类的静态成员函数

静态全局变量
作用域：仅在本文件内
初始化：自动初始化为0
存储在内存的静态存储区

静态局部变量
作用域：仅在本函数内或者语句块内
初始化：自动初始化为0
存储在内存的静态存储区，局部变量离开作用域没有被销毁，下一次调用的时候还可以保持原来的赋值，用于可重用的函数
普通的局部变量存放在栈上，会因为栈帧的释放而被释放掉。

静态函数
作用域：仅在本文件内部可见

* 全局变量，全局静态变量，局部静态变量存储在内存的静态存储区，局部变量存储在内存的栈区。

类的静态成员变量
类的静态成员变量属于类，而不是具体某个对象。
对象共享类的静态成员，类的静态成员只存储一处。
类的静态成员变量就没有this指针了，必须通过类名访问。

类的静态成员函数
静态成员函数的实现中，不能直接引用类中的非静态成员
类的静态函数要引入非静态成员，需要通过对象名来指定

为什么静态成员不能在类内初始化
在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。
为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
class A
{  
private:
    static int count ; // 类内声明
};
int A::count = 0 ; // 类外初始化，不必再加static关键字

https://blog.csdn.net/mm_hh/article/details/77126878
https://www.modb.pro/db/454387
https://blog.csdn.net/weixin_43478836/article/details/91399211

静态函数与普通函数
作用域不同，只在定义该变量的源文件内有效。只在当前源文件中使用的函数应该说明为内部函数(静态函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。

静态全局变量与普通的全局变量有什么区别：
静态全局变量只初使化一次，防止在其他文件单元中被引用;

静态局部变量和普通局部变量有什么区别：
静态局部变量只被初始化一次，下一次依据上一次结果值；

静态函数与普通函数有什么区别：
静态函数与普通函数作用域不同，只在定义该变量的源文件内有效；

全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。


extern
1. extern C 用c的编译规则编译
2. extern 表明该变量在别的地方已经定义过了, 声明在这里要使用那个变量.


1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
3.堆区：程序员手动分配并释放的区域，像malloc, new(c++)
3.全局数据区(静态区)【bss段和data段】：存储全局变量和静态变量。
bss段存储未初始化的全局变量和静态变量，以及初始化为0的全局变量和静态变量
data段存储初始化的全局变量和静态变量在一块区域。
4.代码区

空类和空结构体大小，为什么
函数重载和函数重写
访问权限


RAII是什么，可以做哪些事情

野(wild)指针，悬空(dangling)指针
野指针指向未初始化内存的指针
成因：声明指针后没有初始化

悬空指针指向内存被释放的空间的指针
成因：p1和p2同时指向一块内存，释放p2后，p1和p2就成悬空指针了
https://www.cnblogs.com/idorax/p/6475941.html
https://juejin.cn/post/6945421744744333349


普通read-write
四次状态切换（read-write）
四次数据拷贝（2次DMA拷贝，2次CPU拷贝）

零拷贝技术
1. mmap-write
4次状态切换（mmap-write）
3次数据拷贝（2次DMA拷贝，1次CPU拷贝）
用户缓冲区与内核缓冲区映射，实现内核缓冲区与用户缓冲区的共享，直接在内核中进行CPU拷贝
较少了

2. senfile
sendfile方式只使用一个函数就可以完成之前的read+write 和 mmap+write的功能
减少了2次状态切换
2次状态切换
3次数据拷贝（2次DMA拷贝，1次CPU拷贝）

3.splice
适用于管道

https://zhuanlan.zhihu.com/p/640488719


多态
静态多态：重载。在编译时就确定了，在类内
动态多态：




1.
C++容器有哪些
顺序容器：vector, list, queue, stack
关联容器：set, map, unordered_set, unordered_map, unordered_multiset, unordered_multimap

vector:封装了数组，是一段连续内存空间。支持随机访问，就是可以通过下标访问，或者迭代器访问。查询效率高
插入删除后，后续元素都要移动，插入删除效率低
随机访问：亦称直接访问（direct access）数组在内存中是按顺序存放的，可以通过下标直接定位到某一个元素存放的位置。

list:封装了双向链表，内存空间不连续，链表节点存放咋堆区，删除节点会释放内存

queue：队列
stack：栈

unordered_set, unordered_map 底层是hash表，是无序的。
unordered_set内元素的值就是它的键，unordered_map内保存元素的键值对

set, map 底层是红黑树。根据二叉搜索树的性质对插入进行排序。
map存放键值对pair

unordered_multiset, unordered_multimap 允许数据重复，冗余，对于set允许数据重复，对于map允许一个key有多个value。

2. list 和 vector有什么区别
list封装了链表，vector封装了数组
数组可以随机访问，就是根据下标访问和迭代器访问。
链表可以顺序访问。

数组的查询效率高，链表的增加删除效率高

3. 
public、protected、private继承的区别
子类可以访问基类的public和protected成员。
对于public成员，用何种方式继承，子类就是何种成员。
对于protected成员，用public和protected继承，子类成员都是protected，用private继承，子类成员是private
对于private成员，不能被继承。
子类访问基类的private成员，可以在基类中声明子类是友元，或者在基类中通过public函数访问private成员，子类调用这个public函数。https://blog.csdn.net/qq583083658/article/details/80740299


4.




