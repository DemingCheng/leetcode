C和C++的区别
编译过程
指针和引用的区别（4点）
struct和class的区别
# static关键字
静态全局变量
静态局部变量
静态函数
类的静态成员变量
类的静态成员函数

静态全局变量
作用域：仅在本文件内
初始化：自动初始化为0
存储在内存的静态存储区

静态局部变量
作用域：仅在本函数内或者语句块内
初始化：自动初始化为0
存储在内存的静态存储区，局部变量离开作用域没有被销毁，下一次调用的时候还可以保持原来的赋值，用于可重用的函数
普通的局部变量存放在栈上，会因为栈帧的释放而被释放掉。

静态函数
作用域：仅在本文件内部可见

* 全局变量，全局静态变量，局部静态变量存储在内存的静态存储区，局部变量存储在内存的栈区。

类的静态成员变量
类的静态成员变量属于类，而不是具体某个对象。
对象共享类的静态成员，类的静态成员只存储一处。
类的静态成员变量就没有this指针了，必须通过类名访问。

类的静态成员函数
静态成员函数的实现中，不能直接引用类中的非静态成员
类的静态函数要引入非静态成员，需要通过对象名来指定

为什么静态成员不能在类内初始化
在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。
为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
class A
{  
private:
    static int count ; // 类内声明
};
int A::count = 0 ; // 类外初始化，不必再加static关键字

https://blog.csdn.net/mm_hh/article/details/77126878
https://www.modb.pro/db/454387
https://blog.csdn.net/weixin_43478836/article/details/91399211

静态函数与普通函数
作用域不同，只在定义该变量的源文件内有效。只在当前源文件中使用的函数应该说明为内部函数(静态函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。

静态全局变量与普通的全局变量有什么区别：
静态全局变量只初使化一次，防止在其他文件单元中被引用;

静态局部变量和普通局部变量有什么区别：
静态局部变量只被初始化一次，下一次依据上一次结果值；

静态函数与普通函数有什么区别：
静态函数与普通函数作用域不同，只在定义该变量的源文件内有效；

全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。


extern
1. extern C 用c的编译规则编译
2. extern 表明该变量在别的地方已经定义过了, 声明在这里要使用那个变量.


1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
3.堆区：程序员手动分配并释放的区域，像malloc, new(c++)
3.全局数据区(静态区)【bss段和data段】：存储全局变量和静态变量。
bss段存储未初始化的全局变量和静态变量，以及初始化为0的全局变量和静态变量
data段存储初始化的全局变量和静态变量在一块区域。
4.代码区

空类和空结构体大小，为什么
函数重载和函数重写
访问权限


RAII是什么，可以做哪些事情

野(wild)指针，悬空(dangling)指针
野指针指向未初始化内存的指针
成因：声明指针后没有初始化

悬空指针指向内存被释放的空间的指针
成因：p1和p2同时指向一块内存，释放p2后，p1和p2就成悬空指针了
https://www.cnblogs.com/idorax/p/6475941.html
https://juejin.cn/post/6945421744744333349


普通read-write
四次状态切换（read-write）
四次数据拷贝（2次DMA拷贝，2次CPU拷贝）

零拷贝技术
1. mmap-write
4次状态切换（mmap-write）
3次数据拷贝（2次DMA拷贝，1次CPU拷贝）
用户缓冲区与内核缓冲区映射，实现内核缓冲区与用户缓冲区的共享，直接在内核中进行CPU拷贝
较少了

2. senfile
sendfile方式只使用一个函数就可以完成之前的read+write 和 mmap+write的功能
减少了2次状态切换
2次状态切换
3次数据拷贝（2次DMA拷贝，1次CPU拷贝）

3.splice
适用于管道

https://zhuanlan.zhihu.com/p/640488719


多态
静态多态：重载。在编译时就确定了，在类内
动态多态：
